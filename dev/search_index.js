var documenterSearchIndex = {"docs":
[{"location":"guide/#Guide","page":"Guide","title":"Guide","text":"","category":"section"},{"location":"guide/#Installation","page":"Guide","title":"Installation","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"This project is published in the Melted Tofu Registry.  To use GameBoy.jl, add the registry (]registry add https://github.com/meltedtofu/MeltedTofuRegistry.git) and then use the usual package commands to install ]add GameBoy.","category":"page"},{"location":"guide/#Constructing-an-Emulator","page":"Guide","title":"Constructing an Emulator","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Create an emulator by calling the Emulator constructor with the path to a Game Boy rom file; e = Emulator(\"path-to-rom.gb\").","category":"page"},{"location":"guide/#Emulating-a-Frame","page":"Guide","title":"Emulating a Frame","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Emulate the next frame and return the pixels; pixels = doframe!(e).","category":"page"},{"location":"guide/#Pressing-a-Button","page":"Guide","title":"Pressing a Button","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Press a button with buttonstate!. Don't forget to release it on the next frame - many games wait for the release to trigger the in-game action.","category":"page"},{"location":"guide/#Saving-a-Frame-as-an-Image","page":"Guide","title":"Saving a Frame as an Image","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"The pixels can be saved as an image with FileIO and Images. Just make sure to reinterpret the pixels into the correct color space!","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"This is how I generated the reference images for the Blargg test roms.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"using GameBoy\nusing FileIO, Images\n\ne = Emulator_(\"test/roms/\")\nfor _ ∈ 1:60*60\n  doframe!(e)\nend\n\npixels = doframe!(e)\nsave(File{format\"PNG\"}(\"blargg_cpu_instrs.png\"), reinterpret(BGRA{N0f8}, pixels))","category":"page"},{"location":"guide/#Saving-many-Frames-as-a-Video","page":"Guide","title":"Saving many Frames as a Video","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Multiple frames can be stitched together into a video with VideoIO. The target_pix_fmt and AV_PIX_FMT are selected to be compatible with Quicktime Player. I'm sure that there is a more elegant way to convert the pixels. Submit a PR if you figure it out!","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"using GameBoy\nusing VideoIO\n\nrecorder = open_video_out(joinpath(\"gameboy.recording.mp4\"),\n                          VideoIO.VIO_PIX_FMT_DEF_ELTYPE_LU[VideoIO.AV_PIX_FMT_RGB24],\n                          (144,160);\n                          framerate=60,\n                          target_pix_fmt=VideoIO.AV_PIX_FMT_YUV420P)\n\nframe = Matrix{RGB{N0f8}}(undef, 144, 160)\n\nfor j in 1:144\n    for jj in 1:160\n        frame[j, jj] = convert(RGB{N0f8}, reinterpret(ARGB32, pixels[j, jj]))\n    end\nend\n\nwrite(recorder, frame)\nclose_video_out!(recorder)","category":"page"},{"location":"performance/#Performance","page":"Performance","title":"Performance","text":"","category":"section"},{"location":"performance/#Profiling-Code","page":"Performance","title":"Profiling Code","text":"","category":"section"},{"location":"performance/#Profiling-Memory-Allocation","page":"Performance","title":"Profiling Memory Allocation","text":"","category":"section"},{"location":"performance/#Benchmarking","page":"Performance","title":"Benchmarking","text":"","category":"section"},{"location":"accuracy/#Accuracy","page":"Accuracy","title":"Accuracy","text":"","category":"section"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Here lie all of the docstrings in the GameBoy.jl codebase.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [GameBoy, \n           GameBoy.Processor, \n           GameBoy.Carts, \n           GameBoy.Component, \n           GameBoy.DirectMemoryAccess, \n           GameBoy.RandomAccessMemory, \n           GameBoy.Video,\n           GameBoy.Interrupts,\n           GameBoy.IO,\n           GameBoy.Clock_,\n           GameBoy.MemoryMappingUnit,\n          ]","category":"page"},{"location":"reference/#GameBoy.Button","page":"Reference","title":"GameBoy.Button","text":"All of the buttons that can be pressed\n\n\n\n\n\n","category":"type"},{"location":"reference/#GameBoy.Emulator","page":"Reference","title":"GameBoy.Emulator","text":"The state of an emulator.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GameBoy.Component.reset!-Tuple{Emulator}","page":"Reference","title":"GameBoy.Component.reset!","text":"Power cycle the emulator\n\n\n\n\n\n","category":"method"},{"location":"reference/#GameBoy.buttonstate!-Tuple{Emulator, Button, Bool}","page":"Reference","title":"GameBoy.buttonstate!","text":"Directly set the state of a button.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GameBoy.doframe!-Tuple{Emulator}","page":"Reference","title":"GameBoy.doframe!","text":"Run one frame of emulation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GameBoy.execute-Tuple{Button, Emulator}","page":"Reference","title":"GameBoy.execute","text":"Press a button in the emulator.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GameBoy.ram!-Tuple{Emulator, Vector{UInt8}}","page":"Reference","title":"GameBoy.ram!","text":"Restore cartridge RAM. Use ram to capture the state.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GameBoy.ram-Tuple{Emulator}","page":"Reference","title":"GameBoy.ram","text":"Grab a copy of the cartridge RAM. This captures the save state. Use ram! to restore this state.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GameBoy.read-Tuple{Emulator, UInt16}","page":"Reference","title":"GameBoy.read","text":"Read an arbitrary byte of memory\n\n\n\n\n\n","category":"method"},{"location":"reference/#GameBoy.Processor.Cpu","page":"Reference","title":"GameBoy.Processor.Cpu","text":"Main processor\n\n\n\n\n\n","category":"type"},{"location":"reference/#GameBoy.Carts.Cartridge","page":"Reference","title":"GameBoy.Carts.Cartridge","text":"The place that stores game data. Traditionally stored on removable media to swap between different games.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GameBoy.DirectMemoryAccess.DMA","page":"Reference","title":"GameBoy.DirectMemoryAccess.DMA","text":"Direct Memory Access metadata\n\n\n\n\n\n","category":"type"},{"location":"reference/#GameBoy.RandomAccessMemory.Ram","page":"Reference","title":"GameBoy.RandomAccessMemory.Ram","text":"Random Access Memory.\n\n\n\n\n\n","category":"type"},{"location":"reference/#GameBoy.Video.PPU","page":"Reference","title":"GameBoy.Video.PPU","text":"Video subsystem\n\n\n\n\n\n","category":"type"},{"location":"reference/#GameBoy.Interrupts.Interrupt","page":"Reference","title":"GameBoy.Interrupts.Interrupt","text":"Bit values of each interrupt in the system\n\n\n\n\n\n","category":"type"},{"location":"reference/#GameBoy.IO.IORegisters","page":"Reference","title":"GameBoy.IO.IORegisters","text":"Addresses of IO devices relative to 0xff00\n\nIntentionally skipping sound since it is unimplemented in this emulator\n\n\n\n\n\n","category":"type"},{"location":"reference/#GameBoy.Clock_.Clock","page":"Reference","title":"GameBoy.Clock_.Clock","text":"Main System Clock\n\n\n\n\n\n","category":"type"},{"location":"reference/#GameBoy.MemoryMappingUnit.Mmu","page":"Reference","title":"GameBoy.MemoryMappingUnit.Mmu","text":"Memory Mapping Unit Read and write bytes to the correct subsystem based on address.\n\n\n\n\n\n","category":"type"},{"location":"#GameBoy.jl","page":"Overview","title":"GameBoy.jl","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"A GameBoy emulator.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Documentation Build Status Coverage\nDEV (Image: ) (Image: codecov)","category":"page"},{"location":"#Introduction","page":"Overview","title":"Introduction","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"There are as many Game Boy emulators as ther eare users on GitHub. Why make another one? And why use Julia?","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"I grew up playing Pokémon and thought that it would be fun to build agents to play the game autonomously. I also spent the majority of my career using languages built on top of LLVM from C++, to Rust, and now Julia. Mostly switching to the language best suited to the problem domain.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Since I am primarily focused on Julia and this side project benefits from the performance and distributed computing aspects of Julia it was an easy choice. While Julia easily integrates with C, C++, and Python building the emulator within Julia reduces friction. Sublime, Julia LSP, and the testing/documentation infrastructure can be reused across projects. @code_llvm and @distributed work for both the emulator and any agents I build. Less context switching overall.","category":"page"},{"location":"#Installation","page":"Overview","title":"Installation","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"This project is published in the Melted Tofu Registry.  To use GameBoy.jl, add the registry (]registry add https://github.com/meltedtofu/MeltedTofuRegistry.git) and then use the usual package commands to install ]add GameBoy.","category":"page"},{"location":"#Quickstart","page":"Overview","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The engine is primarily targeted as an engine for game playing agents.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The emulator is driven externally by whatever application you want to build. Just call doframe! to emulate the next frame and receive a matrix of pixels. ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"using GameBoy\n\ne = Emulator(\"path-to-rom.gb\")\nfor i in 1:1*60*60\n    doframe!(e)\nend","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"For more complex intractions (read: any interaction at all) check out the tutorials.","category":"page"},{"location":"#License-Information","page":"Overview","title":"License Information","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"This project uses the MIT license. You can find the full text in LICENSE.","category":"page"}]
}
